using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems;
using TMPro;

[System.Serializable]
public class Enhanced3DWaypoint
{
    public string id;
    public Vector3 position;
    public Quaternion rotation;
    public WaypointType type;
    public string description;
    public DateTime timestamp;
    
    // 3D Environment data
    public List<Vector3> nearbyPlanePoints = new List<Vector3>();
    public List<Vector3> nearbyFeaturePoints = new List<Vector3>();
    public float groundHeight;
    public Vector3 surfaceNormal;
    
    // Navigation metadata
    public float distanceToNext;
    public float bearingToNext;
    public List<string> nearbyLandmarks = new List<string>();
    public int difficultyLevel; // 1-5 scale
    public bool hasObstacleWarning;
    
    // Audio cues
    public string audioDescription;
    public string approachSound; // Path to custom sound file
    
    // NEW: Enhanced walkability data
    public float walkabilityScore; // 0-1 confidence that this is walkable
    public float slopeAngle;
    public bool isValidated;
    public List<Vector3> alternatePositions = new List<Vector3>(); // Backup positions if main position becomes invalid
}

[System.Serializable]
public class Enhanced3DMap
{
    public string mapId;
    public string name;
    public string description;
    public DateTime createdDate;
    public DateTime lastUsedDate;
    public Vector3 centerPoint;
    public Bounds mapBounds;
    
    public List<Enhanced3DWaypoint> waypoints = new List<Enhanced3DWaypoint>();
    public List<Vector3> environmentFeatures = new List<Vector3>();
    public byte[] environmentFingerprint; // For location validation
    
    // Navigation statistics
    public int timesUsed;
    public float averageNavigationTime;
    public float totalPathLength;
    public int successfulNavigations;
    
    // NEW: Enhanced map metadata
    public float averageWalkabilityScore;
    public int totalObstacles;
    public List<string> environmentTypes = new List<string>(); // Indoor, Outdoor, Mixed, etc.
    public string creatorNotes;
}

public class Enhanced3DMapManager : MonoBehaviour
{
    [Header("References")]
    public HitPointManager hitPointManager;
    public NavigationManager navigationManager;
    public TextToSpeech textToSpeech;
    public TextMeshProUGUI statusText;
    public SafePathPlanner safePathPlanner;
    public AccessibilityManager accessibilityManager;
    
    [Header("Waypoint Settings")]
    public float waypointSpacing = 2.0f; // Optimal spacing between waypoints
    public float environmentScanRadius = 5.0f;
    public int maxWaypointsPerPath = 50;
    public bool autoGenerateDescriptions = true;
    
    [Header("3D Environment Capture")]
    public bool captureEnvironmentData = true;
    public float featurePointDensity = 0.5f;
    public int maxFeaturePointsPerWaypoint = 20;
    public bool validateEnvironmentOnLoad = true;
    
    [Header("Walkability Validation")]
    public float maxGroundSlope = 20f;
    public float minPlaneArea = 1.0f;
    public float walkabilityThreshold = 0.7f;
    public bool onlyUseValidatedWaypoints = true;
    
    [Header("Audio Enhancement")]
    public bool generateAudioCues = true;
    public AudioClip[] waypointSounds;
    public AudioClip[] directionSounds;
    public AudioClip pathRecordingStartSound;
    public AudioClip pathRecordingStopSound;
    public AudioClip waypointAddedSound;
    
    [Header("Navigation Enhancement")]
    public bool enablePredictiveGuidance = true;
    public bool enableEnvironmentAwareness = true;
    public float guidanceUpdateFrequency = 1.0f;
    public float obstacleDetectionRange = 3.0f;
    
    // AR Components
    private ARPointCloudManager pointCloudManager;
    private ARPlaneManager planeManager;
    private Camera arCamera;
    
    // Current map data
    private Enhanced3DMap currentMap;
    private List<Enhanced3DWaypoint> activeWaypoints = new List<Enhanced3DWaypoint>();
    
    // Navigation state
    private int currentWaypointIndex = 0;
    private Vector3 lastUserPosition;
    private bool isNavigating = false;
    private bool isRecording = false;
    
    // Recording state
    private Coroutine recordingCoroutine;
    private Vector3 lastRecordedPosition;
    private float lastRecordingTime;
    
    // Integration state
    private bool isIntegratedWithNavManager = false;
    private bool isIntegratedWithHitPointManager = false;
    
    void Start()
    {
        // Find AR components
        pointCloudManager = FindObjectOfType<ARPointCloudManager>();
        planeManager = FindObjectOfType<ARPlaneManager>();
        arCamera = Camera.main;
        
        if (arCamera == null)
            arCamera = FindObjectOfType<Camera>();
        
        // Find manager references if not set
        if (hitPointManager == null)
            hitPointManager = FindObjectOfType<HitPointManager>();
            
        if (navigationManager == null)
            navigationManager = FindObjectOfType<NavigationManager>();
            
        if (textToSpeech == null)
            textToSpeech = FindObjectOfType<TextToSpeech>();
            
        if (safePathPlanner == null)
            safePathPlanner = FindObjectOfType<SafePathPlanner>();
            
        if (accessibilityManager == null)
            accessibilityManager = FindObjectOfType<AccessibilityManager>();
            
        // Initialize
        InitializeMapManager();
        
        // Set up integration
        SetupIntegration();
    }
    
    private void SetupIntegration()
    {
        // Integrate with NavigationManager
        if (navigationManager != null)
        {
            navigationManager.enhanced3DMapManager = this;
            isIntegratedWithNavManager = true;
            Debug.Log("Enhanced3DMapManager: Integrated with NavigationManager");
        }
        
        // Integrate with HitPointManager
        if (hitPointManager != null)
        {
            hitPointManager.enhanced3DMapManager = this;
            isIntegratedWithHitPointManager = true;
            Debug.Log("Enhanced3DMapManager: Integrated with HitPointManager");
        }
    }
    
    private void InitializeMapManager()
    {
        // Create maps directory if it doesn't exist
        string mapsPath = GetMapsDirectory();
        if (!Directory.Exists(mapsPath))
        {
            Directory.CreateDirectory(mapsPath);
        }
        
        // Initialize current map
        currentMap = new Enhanced3DMap();
        currentMap.mapId = Guid.NewGuid().ToString();
        currentMap.createdDate = DateTime.Now;
        
        Debug.Log("Enhanced 3D Map Manager initialized");
        UpdateStatus("Enhanced 3D Map Manager ready");
    }
    
    #region Path Recording
    
    public void StartPathRecording(string pathName = "")
    {
        if (isRecording)
        {
            SpeakMessage("Path recording is already active");
            return;
        }
        
        if (string.IsNullOrEmpty(pathName))
        {
            pathName = "EnhancedPath_" + DateTime.Now.ToString("yyyyMMdd_HHmmss");
        }
        
        currentMap.name = pathName;
        currentMap.description = "Enhanced 3D navigation path with walkability validation";
        activeWaypoints.Clear();
        currentWaypointIndex = 0;
        isRecording = true;
        
        // Play recording start sound
        if (pathRecordingStartSound != null && navigationManager?.audioSource != null)
        {
            navigationManager.audioSource.PlayOneShot(pathRecordingStartSound);
        }
        
        // Start environment scanning
        recordingCoroutine = StartCoroutine(RecordPathWithOptimalWaypoints());
        
        if (textToSpeech != null)
            textToSpeech.Speak("Enhanced path recording started. Walk slowly along your desired route. I will place waypoints only on safe, walkable surfaces.");
            
        UpdateStatus("Recording enhanced path: " + pathName);
        
        // Clear existing waypoints in HitPointManager if integrated
        if (isIntegratedWithHitPointManager && hitPointManager != null)
        {
            hitPointManager.ClearCurrentWaypoints();
            hitPointManager.poseClassList.Clear();
        }
    }
    
    private IEnumerator RecordPathWithOptimalWaypoints()
    {
        lastRecordedPosition = Vector3.zero;
        lastRecordingTime = Time.time;
        bool isFirstWaypoint = true;
        
        while (isRecording && activeWaypoints.Count < maxWaypointsPerPath)
        {
            Vector3 currentPosition = arCamera.transform.position;
            
            // Check if we should place a new waypoint
            bool shouldPlaceWaypoint = false;
            
            if (isFirstWaypoint)
            {
                shouldPlaceWaypoint = true;
                isFirstWaypoint = false;
            }
            else
            {
                float distanceFromLast = Vector3.Distance(currentPosition, lastRecordedPosition);
                float timeSinceLast = Time.time - lastRecordingTime;
                
                // Place waypoint based on distance and time
                if (distanceFromLast >= waypointSpacing || timeSinceLast > 5.0f)
                {
                    shouldPlaceWaypoint = true;
                }
            }
            
            if (shouldPlaceWaypoint)
            {
                // Validate this is a walkable position
                if (IsPositionWalkable(currentPosition))
                {
                    yield return StartCoroutine(CreateEnhancedWaypoint(currentPosition));
                    lastRecordedPosition = currentPosition;
                    lastRecordingTime = Time.time;
                    
                    UpdateStatus($"Recorded waypoint {activeWaypoints.Count} (validated walkable)");
                }
                else
                {
                    // Try to find nearby walkable position
                    Vector3 walkablePosition = FindNearbyWalkablePosition(currentPosition);
                    if (walkablePosition != Vector3.zero)
                    {
                        yield return StartCoroutine(CreateEnhancedWaypoint(walkablePosition));
                        lastRecordedPosition = walkablePosition;
                        lastRecordingTime = Time.time;
                        
                        UpdateStatus($"Recorded waypoint {activeWaypoints.Count} (adjusted to walkable surface)");
                    }
                    else
                    {
                        UpdateStatus("Waiting for walkable surface...");
                    }
                }
            }
            
            yield return new WaitForSeconds(0.5f); // Check every half second
        }
        
        // Auto-complete if we hit max waypoints
        if (activeWaypoints.Count >= maxWaypointsPerPath)
        {
            CompletePathRecording();
        }
    }
    
    private IEnumerator CreateEnhancedWaypoint(Vector3 position)
    {
        Enhanced3DWaypoint waypoint = new Enhanced3DWaypoint();
        waypoint.id = Guid.NewGuid().ToString();
        waypoint.position = position;
        waypoint.rotation = arCamera.transform.rotation;
        waypoint.timestamp = DateTime.Now;
        waypoint.type = activeWaypoints.Count == 0 ? WaypointType.StartPoint : WaypointType.PathPoint;
        
        // Validate walkability
        waypoint.walkabilityScore = CalculateWalkabilityScore(position);
        waypoint.slopeAngle = CalculateSlopeAngle(position);
        waypoint.isValidated = waypoint.walkabilityScore >= walkabilityThreshold;
        
        // Capture 3D environment data
        if (captureEnvironmentData)
        {
            yield return StartCoroutine(Capture3DEnvironmentData(waypoint));
        }
        
        // Generate description
        if (autoGenerateDescriptions)
        {
            waypoint.description = GenerateWaypointDescription(waypoint);
        }
        
        // Generate audio description
        if (generateAudioCues)
        {
            waypoint.audioDescription = GenerateAudioDescription(waypoint);
        }
        
        // Calculate navigation metadata
        if (activeWaypoints.Count > 0)
        {
            var previousWaypoint = activeWaypoints[activeWaypoints.Count - 1];
            previousWaypoint.distanceToNext = Vector3.Distance(previousWaypoint.position, waypoint.position);
            previousWaypoint.bearingToNext = CalculateBearing(previousWaypoint.position, waypoint.position);
        }
        
        activeWaypoints.Add(waypoint);
        
        // Create visual waypoint in the scene
        CreateVisualWaypoint(waypoint);
        
        // Play waypoint added sound
        if (waypointAddedSound != null && navigationManager?.audioSource != null)
        {
            navigationManager.audioSource.PlayOneShot(waypointAddedSound);
        }
        
        // Provide audio feedback
        if (textToSpeech != null)
        {
            string feedback = $"Waypoint {activeWaypoints.Count} recorded";
            if (!string.IsNullOrEmpty(waypoint.description))
            {
                feedback += ". " + waypoint.description;
            }
            
            if (!waypoint.isValidated)
            {
                feedback += ". Warning: walkability validation failed.";
            }
            
            textToSpeech.Speak(feedback);
        }
    }
    
    public void CompletePathRecording()
    {
        if (!isRecording)
        {
            SpeakMessage("No active path recording to complete");
            return;
        }
        
        isRecording = false;
        
        if (recordingCoroutine != null)
        {
            StopCoroutine(recordingCoroutine);
            recordingCoroutine = null;
        }
        
        if (activeWaypoints.Count > 0)
        {
            // Mark last waypoint as end point
            activeWaypoints[activeWaypoints.Count - 1].type = WaypointType.EndPoint;
            
            // Update the visual for the last waypoint
            if (isIntegratedWithHitPointManager && hitPointManager != null)
            {
                hitPointManager.UpdateWaypointVisual(hitPointManager.poseClassList.Count - 1);
            }
            
            // Update map metadata
            currentMap.waypoints = new List<Enhanced3DWaypoint>(activeWaypoints);
            currentMap.totalPathLength = CalculateTotalPathLength();
            currentMap.averageWalkabilityScore = CalculateAverageWalkabilityScore();
            currentMap.centerPoint = CalculateCenterPoint();
            currentMap.mapBounds = CalculateMapBounds();
            
            // Generate environment fingerprint for validation
            currentMap.environmentFingerprint = GenerateEnvironmentFingerprint();
            
            // Auto-save the map
            SaveEnhanced3DMap();
            
            // Play completion sound
            if (pathRecordingStopSound != null && navigationManager?.audioSource != null)
            {
                navigationManager.audioSource.PlayOneShot(pathRecordingStopSound);
            }
            
            if (textToSpeech != null)
            {
                int validatedWaypoints = activeWaypoints.Count(w => w.isValidated);
                textToSpeech.Speak($"Enhanced path recording completed. {activeWaypoints.Count} waypoints recorded over {currentMap.totalPathLength:F1} meters. {validatedWaypoints} waypoints are validated as walkable.");
            }
            
            UpdateStatus($"Enhanced path completed: {currentMap.name}");
        }
        else
        {
            SpeakMessage("No waypoints were recorded");
        }
    }
    
    #endregion
    
    #region Walkability Validation
    
    private bool IsPositionWalkable(Vector3 position)
    {
        float walkabilityScore = CalculateWalkabilityScore(position);
        return walkabilityScore >= walkabilityThreshold;
    }
    
    private float CalculateWalkabilityScore(Vector3 position)
    {
        float score = 0f;
        int checks = 0;
        
        // Check 1: Raycast downward to find ground
        RaycastHit hit;
        if (Physics.Raycast(position + Vector3.up * 0.5f, Vector3.down, out hit, 2.0f))
        {
            // Check surface normal (slope)
            float slopeAngle = Vector3.Angle(hit.normal, Vector3.up);
            if (slopeAngle <= maxGroundSlope)
            {
                score += 0.4f; // 40% for good slope
            }
            else
            {
                score += Mathf.Max(0, 0.4f * (1f - (slopeAngle - maxGroundSlope) / 45f));
            }
            checks++;
        }
        
        // Check 2: AR Plane detection
        if (planeManager != null)
        {
            foreach (ARPlane plane in planeManager.trackables)
            {
                if (plane.alignment == PlaneAlignment.HorizontalUp)
                {
                    float distance = Vector3.Distance(position, plane.center);
                    if (distance < 1.0f && plane.size.x * plane.size.y >= minPlaneArea)
                    {
                        score += 0.3f; // 30% for being on detected plane
                        checks++;
                        break;
                    }
                }
            }
        }
        
        // Check 3: Obstacle detection
        bool hasNearbyObstacles = false;
        Collider[] obstacles = Physics.OverlapSphere(position, 0.5f);
        foreach (Collider obstacle in obstacles)
        {
            if (obstacle.CompareTag("Obstacle"))
            {
                hasNearbyObstacles = true;
                break;
            }
        }
        
        if (!hasNearbyObstacles)
        {
            score += 0.3f; // 30% for no nearby obstacles
        }
        checks++;
        
        // Normalize score
        return checks > 0 ? score : 0f;
    }
    
    private float CalculateSlopeAngle(Vector3 position)
    {
        RaycastHit hit;
        if (Physics.Raycast(position + Vector3.up * 0.5f, Vector3.down, out hit, 2.0f))
        {
            return Vector3.Angle(hit.normal, Vector3.up);
        }
        return 0f;
    }
    
    private Vector3 FindNearbyWalkablePosition(Vector3 originalPosition)
    {
        // Search in a circle around the original position
        float searchRadius = 2.0f;
        int searchSteps = 8;
        
        for (float radius = 0.5f; radius <= searchRadius; radius += 0.5f)
        {
            for (int i = 0; i < searchSteps; i++)
            {
                float angle = (float)i / searchSteps * 360f * Mathf.Deg2Rad;
                Vector3 testPosition = originalPosition + new Vector3(
                    Mathf.Cos(angle) * radius,
                    0,
                    Mathf.Sin(angle) * radius
                );
                
                if (IsPositionWalkable(testPosition))
                {
                    return testPosition;
                }
            }
        }
        
        return Vector3.zero; // No walkable position found
    }
    
    private float CalculateAverageWalkabilityScore()
    {
        if (activeWaypoints.Count == 0) return 0f;
        
        float totalScore = 0f;
        foreach (var waypoint in activeWaypoints)
        {
            totalScore += waypoint.walkabilityScore;
        }
        
        return totalScore / activeWaypoints.Count;
    }
    
    #endregion
    
    #region Environment Data Capture
    
    private IEnumerator Capture3DEnvironmentData(Enhanced3DWaypoint waypoint)
    {
        // Capture nearby plane data
        if (planeManager != null)
        {
            foreach (ARPlane plane in planeManager.trackables)
            {
                float distance = Vector3.Distance(waypoint.position, plane.center);
                if (distance <= environmentScanRadius)
                {
                    // Store relevant points from the plane boundary
                    var boundaryPoints = plane.boundary;
                    for (int i = 0; i < boundaryPoints.Length && i < 10; i++)
                    {
                        Vector2 point2D = boundaryPoints[i];
                        Vector3 worldPoint = plane.transform.TransformPoint(new Vector3(point2D.x, 0, point2D.y));
                        waypoint.nearbyPlanePoints.Add(worldPoint);
                    }
                    
                    // Store ground height and surface normal for horizontal planes
                    if (plane.alignment == PlaneAlignment.HorizontalUp)
                    {
                        waypoint.groundHeight = plane.center.y;
                        waypoint.surfaceNormal = plane.normal;
                    }
                }
            }
        }
        
        // Capture feature points
        if (pointCloudManager != null && pointCloudManager.trackables.count > 0)
        {
            List<Vector3> nearbyFeatures = new List<Vector3>();
            
            foreach (var pointCloud in pointCloudManager.trackables)
            {
                if (pointCloud.positions.HasValue)
                {
                    foreach (var point in pointCloud.positions.Value)
                    {
                        float distance = Vector3.Distance(waypoint.position, point);
                        if (distance <= environmentScanRadius)
                        {
                            nearbyFeatures.Add(point);
                        }
                    }
                }
            }
            
            // Limit feature points to prevent data bloat
            if (nearbyFeatures.Count > maxFeaturePointsPerWaypoint)
            {
                // Sample evenly
                for (int i = 0; i < maxFeaturePointsPerWaypoint; i++)
                {
                    int index = (i * nearbyFeatures.Count) / maxFeaturePointsPerWaypoint;
                    waypoint.nearbyFeaturePoints.Add(nearbyFeatures[index]);
                }
            }
            else
            {
                waypoint.nearbyFeaturePoints.AddRange(nearbyFeatures);
            }
        }
        
        yield return null;
    }
    
    #endregion
    
    #region Description Generation
    
    private string GenerateWaypointDescription(Enhanced3DWaypoint waypoint)
    {
        List<string> descriptions = new List<string>();
        
        // Walkability assessment
        if (waypoint.walkabilityScore >= 0.8f)
        {
            descriptions.Add("Safe walkable surface");
        }
        else if (waypoint.walkabilityScore >= 0.6f)
        {
            descriptions.Add("Walkable with caution");
        }
        else
        {
            descriptions.Add("Questionable walkability");
        }
        
        // Slope information
        if (waypoint.slopeAngle > 10f)
        {
            descriptions.Add($"Slope {waypoint.slopeAngle:F0} degrees");
        }
        
        // Analyze nearby planes
        if (waypoint.nearbyPlanePoints.Count > 0)
        {
            descriptions.Add("Near detected surface");
        }
        
        // Check for walls (vertical planes)
        bool hasWalls = false;
        if (planeManager != null)
        {
            foreach (ARPlane plane in planeManager.trackables)
            {
                if (plane.alignment == PlaneAlignment.Vertical &&
                    Vector3.Distance(waypoint.position, plane.center) <= environmentScanRadius)
                {
                    hasWalls = true;
                    break;
                }
            }
        }
        
        if (hasWalls)
        {
            descriptions.Add("Wall nearby");
        }
        
        // Analyze feature point density
        if (waypoint.nearbyFeaturePoints.Count > 15)
        {
            descriptions.Add("Complex environment");
        }
        else if (waypoint.nearbyFeaturePoints.Count < 5)
        {
            descriptions.Add("Open area");
        }
        
        // Position in path
        if (waypoint.type == WaypointType.StartPoint)
        {
            descriptions.Add("Journey starting point");
        }
        else if (waypoint.type == WaypointType.EndPoint)
        {
            descriptions.Add("Destination");
        }
        else
        {
            descriptions.Add($"Enhanced waypoint {activeWaypoints.Count + 1}");
        }
        
        return string.Join(", ", descriptions);
    }
    
    private string GenerateAudioDescription(Enhanced3DWaypoint waypoint)
    {
        string audio = "";
        
        if (waypoint.type == WaypointType.StartPoint)
        {
            audio = "Starting your enhanced navigation journey from here. ";
        }
        else if (waypoint.type == WaypointType.EndPoint)
        {
            audio = "You have reached your destination. ";
        }
        else
        {
            audio = $"Enhanced waypoint {activeWaypoints.Count + 1}. ";
        }
        
        // Add walkability context
        if (waypoint.walkabilityScore >= 0.8f)
        {
            audio += "Safe walkable surface confirmed. ";
        }
        else if (waypoint.walkabilityScore >= 0.6f)
        {
            audio += "Walkable surface detected. ";
        }
        else
        {
            audio += "Caution: walkability uncertain. ";
        }
        
        // Add environment context
        if (waypoint.nearbyPlanePoints.Count > 0)
        {
            audio += "Flat surface detected nearby. ";
        }
        
        if (waypoint.nearbyFeaturePoints.Count > 15)
        {
            audio += "Complex environment with many features. ";
        }
        else if (waypoint.nearbyFeaturePoints.Count < 5)
        {
            audio += "Open area with few obstacles. ";
        }
        
        // Add slope warning
        if (waypoint.slopeAngle > 15f)
        {
            audio += $"Moderate slope of {waypoint.slopeAngle:F0} degrees. ";
        }
        
        return audio;
    }
    
    #endregion
    
    #region Map Management
    
    private float CalculateTotalPathLength()
    {
        float length = 0f;
        for (int i = 0; i < activeWaypoints.Count - 1; i++)
        {
            length += Vector3.Distance(activeWaypoints[i].position, activeWaypoints[i + 1].position);
        }
        return length;
    }
    
    private Vector3 CalculateCenterPoint()
    {
        if (activeWaypoints.Count == 0) return Vector3.zero;
        
        Vector3 sum = Vector3.zero;
        foreach (var waypoint in activeWaypoints)
        {
            sum += waypoint.position;
        }
        return sum / activeWaypoints.Count;
    }
    
    private Bounds CalculateMapBounds()
    {
        if (activeWaypoints.Count == 0) return new Bounds();
        
        Bounds bounds = new Bounds(activeWaypoints[0].position, Vector3.zero);
        foreach (var waypoint in activeWaypoints)
        {
            bounds.Encapsulate(waypoint.position);
        }
        bounds.Expand(5.0f); // Add margin
        return bounds;
    }
    
    private float CalculateBearing(Vector3 from, Vector3 to)
    {
        Vector3 direction = to - from;
        direction.y = 0; // Ignore vertical component
        
        // Calculate angle from north (forward direction)
        float angle = Vector3.SignedAngle(Vector3.forward, direction, Vector3.up);
        return angle;
    }
    
    private byte[] GenerateEnvironmentFingerprint()
    {
        // Create a unique fingerprint of the environment for validation
        List<Vector3> keyPoints = new List<Vector3>();
        
        // Add waypoint positions
        foreach (var waypoint in activeWaypoints)
        {
            keyPoints.Add(waypoint.position);
            keyPoints.AddRange(waypoint.nearbyFeaturePoints.Take(5)); // Add some feature points
        }
        
        // Convert to bytes and hash
        var bytes = new List<byte>();
        foreach (var point in keyPoints)
        {
            bytes.AddRange(BitConverter.GetBytes(point.x));
            bytes.AddRange(BitConverter.GetBytes(point.y));
            bytes.AddRange(BitConverter.GetBytes(point.z));
        }
        
        // Use SHA256 for hashing
        return System.Security.Cryptography.SHA256.Create().ComputeHash(bytes.ToArray());
    }
    
    #endregion
    
    #region File Operations
    
    public void SaveEnhanced3DMap()
    {
        try
        {
            string filePath = Path.Combine(GetMapsDirectory(), currentMap.name + ".json");
            string json = JsonUtility.ToJson(currentMap, true);
            File.WriteAllText(filePath, json);
            
            Debug.Log($"Enhanced 3D map saved: {filePath}");
            
            if (textToSpeech != null)
                textToSpeech.Speak("Enhanced map saved successfully");
                
            UpdateStatus($"Map saved: {currentMap.name}");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error saving enhanced 3D map: {e.Message}");
            if (textToSpeech != null)
                textToSpeech.Speak("Error saving enhanced map");
        }
    }
    
    public List<string> GetAvailableMaps()
    {
        List<string> maps = new List<string>();
        string mapsDir = GetMapsDirectory();
        
        if (Directory.Exists(mapsDir))
        {
            string[] files = Directory.GetFiles(mapsDir, "*.json");
            foreach (string file in files)
            {
                maps.Add(Path.GetFileNameWithoutExtension(file));
            }
        }
        
        return maps;
    }
    
    public bool LoadEnhanced3DMap(string mapName)
    {
        try
        {
            string filePath = Path.Combine(GetMapsDirectory(), mapName + ".json");
            
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Enhanced map file not found: {filePath}");
                return false;
            }
            
            string json = File.ReadAllText(filePath);
            currentMap = JsonUtility.FromJson<Enhanced3DMap>(json);
            
            // Update usage statistics
            currentMap.timesUsed++;
            currentMap.lastUsedDate = DateTime.Now;
            
            // Validate environment if enabled
            if (validateEnvironmentOnLoad)
            {
                StartCoroutine(ValidateEnvironment());
            }
            else
            {
                LoadWaypointsToScene();
            }
            
            UpdateStatus($"Loaded enhanced map: {mapName}");
            return true;
        }
        catch (Exception e)
        {
            Debug.LogError($"Error loading enhanced 3D map: {e.Message}");
            SpeakMessage("Error loading enhanced map");
            return false;
        }
    }
    
    private IEnumerator ValidateEnvironment()
    {
        UpdateStatus("Validating environment...");
        
        if (textToSpeech != null)
            textToSpeech.Speak("Validating environment. Please wait.");
        
        yield return new WaitForSeconds(3.0f); // Allow AR to stabilize
        
        // Generate current environment fingerprint
        byte[] currentFingerprint = GenerateCurrentEnvironmentFingerprint();
        
        // Compare with saved fingerprint
        float similarity = CalculateFingerprintSimilarity(currentMap.environmentFingerprint, currentFingerprint);
        
        if (similarity > 0.6f) // 60% similarity threshold
        {
            UpdateStatus($"Environment validated ({similarity:P0} match)");
            if (textToSpeech != null)
                textToSpeech.Speak($"Environment validated with {similarity:P0} confidence. Loading enhanced path.");
            
            LoadWaypointsToScene();
        }
        else
        {
            UpdateStatus($"Environment mismatch ({similarity:P0} match)");
            if (textToSpeech != null)
                textToSpeech.Speak($"Warning: This may not be the correct location. Environment match is only {similarity:P0}. Loading enhanced path anyway.");
            
            // Load anyway but with warning
            LoadWaypointsToScene();
        }
    }
    
    private byte[] GenerateCurrentEnvironmentFingerprint()
    {
        List<Vector3> currentFeatures = new List<Vector3>();
        
        // Get current feature points
        if (pointCloudManager != null && pointCloudManager.trackables.count > 0)
        {
            foreach (var pointCloud in pointCloudManager.trackables)
            {
                if (pointCloud.positions.HasValue)
                {
                    currentFeatures.AddRange(pointCloud.positions.Value.Take(50));
                }
            }
        }
        
        // Convert to bytes and hash
        var bytes = new List<byte>();
        foreach (var point in currentFeatures)
        {
            bytes.AddRange(BitConverter.GetBytes(point.x));
            bytes.AddRange(BitConverter.GetBytes(point.y));
            bytes.AddRange(BitConverter.GetBytes(point.z));
        }
        
        return System.Security.Cryptography.SHA256.Create().ComputeHash(bytes.ToArray());
    }
    
    private float CalculateFingerprintSimilarity(byte[] fingerprint1, byte[] fingerprint2)
    {
        if (fingerprint1 == null || fingerprint2 == null) return 0f;
        if (fingerprint1.Length != fingerprint2.Length) return 0f;
        
        int matches = 0;
        for (int i = 0; i < fingerprint1.Length; i++)
        {
            if (Math.Abs(fingerprint1[i] - fingerprint2[i]) < 10) // Allow some tolerance
                matches++;
        }
        
        return (float)matches / fingerprint1.Length;
    }
    
    private void LoadWaypointsToScene()
    {
        // Clear existing waypoints in integrated systems
        if (isIntegratedWithHitPointManager && hitPointManager != null)
        {
            hitPointManager.ClearCurrentWaypoints();
            hitPointManager.poseClassList.Clear();
        }
        
        // Load enhanced waypoints
        foreach (var waypoint in currentMap.waypoints)
        {
            // Create PoseClass for compatibility with existing system
            PoseClass poseClass = new PoseClass
            {
                trackingId = waypoint.id,
                position = waypoint.position,
                rotation = waypoint.rotation,
                waypointType = waypoint.type,
                description = waypoint.description
            };
            
            if (isIntegratedWithHitPointManager && hitPointManager != null)
            {
                hitPointManager.poseClassList.Add(poseClass);
            }
        }
        
        // Create visuals if integrated with HitPointManager
        if (isIntegratedWithHitPointManager && hitPointManager != null)
        {
            for (int i = 0; i < hitPointManager.poseClassList.Count; i++)
            {
                hitPointManager.CreateWaypointVisual(i);
            }
        }
        
        UpdateStatus($"Loaded {currentMap.waypoints.Count} enhanced waypoints");
        
        if (textToSpeech != null)
        {
            int validatedWaypoints = currentMap.waypoints.Count(w => w.isValidated);
            textToSpeech.Speak($"Loaded enhanced path {currentMap.name} with {currentMap.waypoints.Count} waypoints. {validatedWaypoints} waypoints are validated as walkable. Total distance: {currentMap.totalPathLength:F1} meters.");
        }
    }
    
    private string GetMapsDirectory()
    {
        string basePath = "";
        
        if (isIntegratedWithHitPointManager && hitPointManager != null)
        {
            basePath = hitPointManager.GetAndroidExternalStoragePath();
        }
        else
        {
            basePath = Application.persistentDataPath;
        }
        
        return Path.Combine(basePath, "Enhanced3DMaps");
    }
    
    #endregion
    
    #region Visual Waypoint Creation
    
    private void CreateVisualWaypoint(Enhanced3DWaypoint waypoint)
    {
        // Create visual representation using existing system if integrated
        if (isIntegratedWithHitPointManager && hitPointManager != null)
        {
            PoseClass poseClass = new PoseClass
            {
                trackingId = waypoint.id,
                position = waypoint.position,
                rotation = waypoint.rotation,
                waypointType = waypoint.type,
                description = waypoint.description
            };
            
            hitPointManager.poseClassList.Add(poseClass);
            hitPointManager.CreateWaypointVisual(hitPointManager.poseClassList.Count - 1);
        }
    }
    
    #endregion
    
    #region Navigation
    
    public void StartEnhancedNavigation()
    {
        if (currentMap == null || currentMap.waypoints.Count == 0)
        {
            SpeakMessage("No enhanced path loaded for navigation");
            return;
        }
        
        isNavigating = true;
        currentWaypointIndex = 0;
        
        // Start navigation with enhanced features
        StartCoroutine(EnhancedNavigationLoop());
        
        if (textToSpeech != null)
        {
            int validatedWaypoints = currentMap.waypoints.Count(w => w.isValidated);
            textToSpeech.Speak($"Enhanced navigation started. Following validated path with {validatedWaypoints} confirmed walkable waypoints. Listen for audio cues to reach your destination safely.");
        }
    }
    
    private IEnumerator EnhancedNavigationLoop()
    {
        while (isNavigating && currentWaypointIndex < currentMap.waypoints.Count)
        {
            Enhanced3DWaypoint currentWaypoint = currentMap.waypoints[currentWaypointIndex];
            Vector3 userPosition = arCamera.transform.position;
            
            // Check if waypoint is reached
            float distance = Vector3.Distance(userPosition, currentWaypoint.position);
            
            if (distance < (navigationManager?.waypointReachedDistance ?? 1.0f))
            {
                // Waypoint reached
                OnWaypointReached(currentWaypoint);
                currentWaypointIndex++;
            }
            else
            {
                // Provide navigation guidance
                ProvideEnhancedGuidance(currentWaypoint, userPosition);
            }
            
            yield return new WaitForSeconds(guidanceUpdateFrequency);
        }
        
        if (currentWaypointIndex >= currentMap.waypoints.Count)
        {
            // Navigation completed
            OnNavigationCompleted();
        }
    }
    
    private void OnWaypointReached(Enhanced3DWaypoint waypoint)
    {
        // Play waypoint sound
        if (navigationManager?.audioSource != null && navigationManager.waypointReachedSound != null)
        {
            navigationManager.audioSource.PlayOneShot(navigationManager.waypointReachedSound);
        }
        
        // Announce waypoint with enhanced information
        if (textToSpeech != null)
        {
            string announcement = "Enhanced waypoint reached";
            if (!string.IsNullOrEmpty(waypoint.audioDescription))
            {
                announcement += ". " + waypoint.audioDescription;
            }
            
            // Add walkability confidence
            if (!waypoint.isValidated)
            {
                announcement += " Caution: walkability validation failed for this point.";
            }
            
            textToSpeech.Speak(announcement);
        }
    }
    
    private void ProvideEnhancedGuidance(Enhanced3DWaypoint targetWaypoint, Vector3 userPosition)
    {
        // Calculate direction to waypoint
        Vector3 direction = targetWaypoint.position - userPosition;
        direction.y = 0; // Ignore height
        
        Vector3 userForward = arCamera.transform.forward;
        userForward.y = 0;
        
        float angle = Vector3.SignedAngle(userForward, direction.normalized, Vector3.up);
        float distance = direction.magnitude;
        
        // Generate enhanced guidance message
        string guidance = GenerateEnhancedGuidanceMessage(angle, distance, targetWaypoint);
        
        if (textToSpeech != null)
        {
            textToSpeech.Speak(guidance);
        }
    }
    
    private string GenerateEnhancedGuidanceMessage(float angle, float distance, Enhanced3DWaypoint waypoint)
    {
        string direction = "";
        
        if (Mathf.Abs(angle) < 15f)
            direction = "straight ahead";
        else if (angle > 0)
            direction = angle > 45f ? "to your right" : "slightly right";
        else
            direction = angle < -45f ? "to your left" : "slightly left";
        
        string message = $"Continue {direction} for {distance:F1} meters";
        
        // Add waypoint-specific information
        if (waypoint.hasObstacleWarning)
        {
            message += ". Caution: obstacles detected in this area";
        }
        
        if (waypoint.nearbyLandmarks.Count > 0)
        {
            message += $". Landmark: {waypoint.nearbyLandmarks[0]}";
        }
        
        // Add walkability information
        if (!waypoint.isValidated)
        {
            message += ". Warning: destination walkability uncertain";
        }
        else if (waypoint.slopeAngle > 15f)
        {
            message += $". Moderate slope of {waypoint.slopeAngle:F0} degrees ahead";
        }
        
        return message;
    }
    
    private void OnNavigationCompleted()
    {
        isNavigating = false;
        
        // Update map statistics
        currentMap.successfulNavigations++;
        SaveEnhanced3DMap(); // Save updated statistics
        
        if (navigationManager?.audioSource != null && navigationManager.destinationReachedSound != null)
        {
            navigationManager.audioSource.PlayOneShot(navigationManager.destinationReachedSound);
        }
        
        if (textToSpeech != null)
        {
            textToSpeech.Speak("Congratulations! You have successfully reached your destination using enhanced 3D navigation with validated walkable waypoints.");
        }
        
        UpdateStatus("Enhanced navigation completed successfully");
    }
    
    public void StopNavigation()
    {
        isNavigating = false;
        UpdateStatus("Enhanced navigation stopped");
        
        if (textToSpeech != null)
        {
            textToSpeech.Speak("Enhanced navigation stopped");
        }
    }
    
    #endregion
    
    #region Public Interface
    
    public bool IsNavigating()
    {
        return isNavigating;
    }
    
    public Enhanced3DMap GetCurrentMap()
    {
        return currentMap;
    }
    
    public int GetCurrentWaypointIndex()
    {
        return currentWaypointIndex;
    }
    
    public bool IsRecording()
    {
        return isRecording;
    }
    
    public float GetPathCompletionPercentage()
    {
        if (currentMap == null || currentMap.waypoints.Count == 0)
            return 0f;
            
        return (float)currentWaypointIndex / currentMap.waypoints.Count;
    }
    
    #endregion
    
    #region Helper Methods
    
    private void UpdateStatus(string message)
    {
        if (statusText != null)
        {
            statusText.text = message;
        }
        Debug.Log("Enhanced3DMapManager: " + message);
    }
    
    private void SpeakMessage(string message)
    {
        if (textToSpeech != null)
        {
            textToSpeech.Speak(message);
        }
        else
        {
            Debug.Log("Enhanced3DMapManager: " + message);
        }
    }
    
    #endregion
}
